<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序城堡挑战 - 算法冒险家</title>
    <!-- 引入FontAwesome图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <!-- 引入排序城堡专用样式 -->
    <link rel="stylesheet" href="styles/sortingCastle.css">
</head>
<body>
    <!-- 顶部导航栏 -->
    <nav class="navbar">
        <a href="index.html" class="navbar-logo">
            <i class="fas fa-code-branch"></i> 算法冒险家
        </a>
        
        <ul class="navbar-menu">
            <li><a href="world-map.html">游戏世界</a></li>
            <li><a href="#leaderboard">排行榜</a></li>
            <li><a href="#daily-challenge">每日挑战</a></li>
            <li><a href="#resources">学习资源</a></li>
        </ul>
        
        <div class="navbar-auth">
            <a href="#login" class="btn btn-outline">登录</a>
            <a href="#register" class="btn btn-primary">注册</a>
        </div>
    </nav>

    <!-- 主内容区域 -->
    <div class="container">
        <h1>排序城堡挑战</h1>
        <p>学习和应用各种排序算法，挑战排序城堡的谜题！</p>
        
        <!-- 排序城堡游戏主体 -->
        <div class="sorting-castle-container">
            <!-- 游戏标题 -->
            <h2 class="game-title">排序城堡挑战</h2>
            
            <!-- 游戏头部信息 -->
            <div class="game-header">
                <h3>城堡入口</h3>
                <div class="game-stats">
                    <div class="stat-item">
                        <i class="fas fa-stopwatch"></i> 时间: <span class="time-display">0.0</span>秒
                    </div>
                    <div class="stat-item">
                        <i class="fas fa-exchange-alt"></i> 移动次数: <span class="moves-display">0</span>
                    </div>
                    <div class="stat-item">
                        <i class="fas fa-star"></i> 星星: <span class="stars-display">0</span>
                    </div>
                </div>
            </div>
            
            <!-- 游戏描述 -->
            <div class="game-description">使用冒泡排序解锁城堡大门</div>
            
            <!-- 游戏主区域 -->
            <div class="game-main">
                <!-- 排序可视化区域 -->
                <div class="visualization-area">
                    <div class="action-buttons">
                        <button class="btn btn-primary sort-button">
                            <i class="fas fa-play"></i> 开始排序
                        </button>
                        <button class="btn btn-secondary pause-button">
                            <i class="fas fa-pause"></i> 暂停
                        </button>
                        <button class="btn btn-secondary hint-button">
                            <i class="fas fa-lightbulb"></i> 算法提示
                        </button>
                    </div>
                    
                    <div class="sorting-elements-container">
                        <div class="sorting-elements">
                            <!-- 排序元素将由JavaScript动态生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 游戏控制区域 -->
                <div class="game-controls">
                    <div class="algorithm-selection">
                        <h4><i class="fas fa-info-circle"></i> 选择排序算法</h4>
                        <div class="algorithm-options">
                            <div class="algorithm-option active" data-algorithm="bubble">冒泡排序</div>
                            <div class="algorithm-option" data-algorithm="insertion">插入排序</div>
                            <div class="algorithm-option" data-algorithm="quick">快速排序</div>
                            <div class="algorithm-option" data-algorithm="merge">归并排序</div>
                        </div>
                    </div>
                    
                    <h4><i class="fas fa-info-circle"></i> 冒泡排序算法说明</h4>
                    <p>冒泡排序通过重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
                    <div class="algorithm-code">
                        <pre>
for (i = 0; i < n-1; i++) {
    for (j = 0; j < n-i-1; j++) {
        if (array[j] > array[j+1]) {
            swap(array[j], array[j+1])
        }
    }
}
                        </pre>
                    </div>
                    <p>时间复杂度: O(n²) - 空间复杂度: O(1)</p>
                    
                    <!-- 算法提示面板 -->
                    <div class="hint-panel">
                        <h4>算法提示</h4>
                        <p>冒泡排序是从左到右比较相邻元素，如果左边元素大于右边元素则交换它们的位置。每一轮迭代都会将当前最大的元素冒泡到最右侧。</p>
                    </div>
                </div>
            </div>
            
            <!-- 关卡选择 -->
            <div class="level-selection">
                <!-- 关卡选择按钮将由JavaScript动态生成 -->
            </div>
        </div>
        
        <!-- 排序算法知识 -->
        <div class="sorting-knowledge">
            <h2>排序算法知识</h2>
            
            <div class="knowledge-tabs">
                <div class="knowledge-tab active" data-tab="bubble-sort">冒泡排序</div>
                <div class="knowledge-tab" data-tab="selection-sort">选择排序</div>
                <div class="knowledge-tab" data-tab="insertion-sort">插入排序</div>
                <div class="knowledge-tab" data-tab="quick-sort">快速排序</div>
                <div class="knowledge-tab" data-tab="merge-sort">归并排序</div>
            </div>
            
            <div class="knowledge-content">
                <div class="knowledge-panel active" id="bubble-sort">
                    <h3>冒泡排序 (Bubble Sort)</h3>
                    <p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
                    
                    <h4>算法步骤</h4>
                    <ol>
                        <li>比较相邻的元素。如果第一个比第二个大，就交换它们。</li>
                        <li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步完成后，最后的元素会是最大的数。</li>
                        <li>针对所有的元素重复以上的步骤，除了最后一个。</li>
                        <li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
                    </ol>
                    
                    <h4>算法特性</h4>
                    <ul>
                        <li>时间复杂度：O(n²)</li>
                        <li>空间复杂度：O(1)</li>
                        <li>稳定性：稳定</li>
                    </ul>
                    
                    <h4>适用场景</h4>
                    <p>冒泡排序适合小规模数据或者基本有序的数据。由于算法简单，常用于教学。</p>
                </div>
                
                <div class="knowledge-panel" id="selection-sort" style="display: none;">
                    <h3>选择排序 (Selection Sort)</h3>
                    <p>选择排序是一种简单直观的排序算法，它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余未排序元素中寻找最小（或最大）元素，然后放到已排序序列的末尾。</p>
                    
                    <h4>算法特性</h4>
                    <ul>
                        <li>时间复杂度：O(n²)</li>
                        <li>空间复杂度：O(1)</li>
                        <li>稳定性：不稳定</li>
                    </ul>
                </div>
                
                <div class="knowledge-panel" id="insertion-sort" style="display: none;">
                    <h3>插入排序 (Insertion Sort)</h3>
                    <p>插入排序的工作方式像排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
                    
                    <h4>算法特性</h4>
                    <ul>
                        <li>时间复杂度：O(n²)</li>
                        <li>空间复杂度：O(1)</li>
                        <li>稳定性：稳定</li>
                    </ul>
                </div>
                
                <div class="knowledge-panel" id="quick-sort" style="display: none;">
                    <h3>快速排序 (Quick Sort)</h3>
                    <p>快速排序采用分治法的策略，选择一个元素作为基准，通过一趟排序将待排序的数据分割成独立的两部分：比基准小的部分和比基准大的部分，然后再按此方法对这两部分数据分别进行快速排序。</p>
                    
                    <h4>算法特性</h4>
                    <ul>
                        <li>时间复杂度：平均 O(n log n)，最坏 O(n²)</li>
                        <li>空间复杂度：O(log n)</li>
                        <li>稳定性：不稳定</li>
                    </ul>
                </div>
                
                <div class="knowledge-panel" id="merge-sort" style="display: none;">
                    <h3>归并排序 (Merge Sort)</h3>
                    <p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。归并排序将待排序的数组分成两个子数组，然后递归地对它们进行排序，最后将两个有序子数组合并成一个有序数组。</p>
                    
                    <h4>算法特性</h4>
                    <ul>
                        <li>时间复杂度：O(n log n)</li>
                        <li>空间复杂度：O(n)</li>
                        <li>稳定性：稳定</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <i class="fas fa-code-branch"></i> 算法冒险家
                </div>
                <div class="footer-links">
                    <a href="#">关于我们</a>
                    <a href="#">联系方式</a>
                    <a href="#">使用条款</a>
                    <a href="#">隐私政策</a>
                </div>
                <div class="footer-social">
                    <a href="#"><i class="fab fa-weixin"></i></a>
                    <a href="#"><i class="fab fa-weibo"></i></a>
                    <a href="#"><i class="fab fa-github"></i></a>
                </div>
            </div>
            <div class="footer-copyright">
                &copy; 2023 算法冒险家. 保留所有权利.
            </div>
        </div>
    </footer>

    <script src="scripts/main.js"></script>
    <!-- 引入排序城堡专用脚本 -->
    <script src="scripts/sortingCastle.js"></script>
    <script>
        // 知识面板切换功能
        document.addEventListener('DOMContentLoaded', function() {
            const knowledgeTabs = document.querySelectorAll('.knowledge-tab');
            const knowledgePanels = document.querySelectorAll('.knowledge-panel');
            
            knowledgeTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有活动标签和面板
                    knowledgeTabs.forEach(t => t.classList.remove('active'));
                    knowledgePanels.forEach(p => p.style.display = 'none');
                    
                    // 激活当前标签和面板
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).style.display = 'block';
                });
            });
            
            // 动态生成关卡选择按钮
            const levelSelection = document.querySelector('.level-selection');
            if (levelSelection) {
                for (let i = 1; i <= 10; i++) {
                    const levelItem = document.createElement('div');
                    levelItem.className = `level-item ${i === 1 ? 'active' : ''} ${!unlocked.includes(i) ? 'locked' : ''}`;
                    levelItem.textContent = `关卡 ${i}`;
                    levelItem.setAttribute('data-level', i);
                    
                    // 仅为解锁的关卡添加点击事件
                    if (unlocked.includes(i)) {
                        levelItem.addEventListener('click', function() {
                            // 更新活动关卡
                            document.querySelectorAll('.level-item').forEach(item => {
                                item.classList.remove('active');
                            });
                            this.classList.add('active');
                            
                            // 加载关卡
                            currentLevel = parseInt(this.getAttribute('data-level'));
                            loadLevel(currentLevel);
                        });
                    }
                    
                    levelSelection.appendChild(levelItem);
                }
            }
        });
    </script>
</body>
</html> 